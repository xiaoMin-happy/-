# re正则表达式及Re库

## 一. re正则表达式

regular expression

- 通用的字符串表达框架

- 简洁表达一组字符串的表达式
- 针对字符串表达的“简洁”和“特征”思想的工具
- 判断某字符串的特征归属（字符串匹配）

### 1. 正则表达式的使用

#### （1）正则表达式在文本处理中的应用——字符串匹配：

- 表达文本类型的特征（比如病毒、入侵等）
- 同时查找或替换一组字符串
- 匹配字符串的全部或部分区域

#### （2）正则表达式的使用：

需要进行编译：将符合正则表达式语法的字符串转换成正则表达式类型

### 2. 正则表达式的语法：

正则表达式是由**字符**和**操作符**构成

| 操作符 | 说明                                                         | 实例                                  |
| ------ | ------------------------------------------------------------ | ------------------------------------- |
| .      | 表示任何单个字符                                             |                                       |
| [ ]    | 字符集，对单个字符给出取值范围                               | [abc]表示a,b,c; [a-z]表示a到z单个字符 |
| [^ ]   | 非字符集，对单个字符给出排除范围                             | [^abc]表示非a或b或c的单个字符         |
| *      | *的前一个字符0次或无限次扩展（**0次扩展相当于删除**）        | abc*表示ab, abc, abcc, abccc等        |
| +      | +的前一个字符1次或无限次扩展                                 | abc+表示abc, abcc, abccc等            |
| ？     | ?的前一个字符0次或1次扩展                                    | abc?表示ab, abc                       |
| \|     | ｜的左右表达式任意一个                                       | abc\|def表示abc, def                  |
| {m}    | 扩展{m}的前一个字符m次                                       | ab{2}表示abbc                         |
| {m,n}  | 扩展{m,n}的前一个字符m至n次（**包含n**）                     | ab{1,2}表示abc, abbc                  |
| ^      | 匹配字符串开头                                               | ^abc表示abc且它在一个字符串的开头     |
| $      | 匹配字符串结尾                                               | abc$表示abc且它在一个字符串的结尾     |
| ( )    | 分组标记，**内部只能使用｜操作符**（通俗来说就像四则运算的小括号一样，把一堆运算放在一起） | (abc)表示abc; (abc\|def)表示abc, def  |
| \d     | 数字，等价于[0-9]                                            |                                       |
| \w     | 单词字符，等价于[A-Za-z0-9_]                                 |                                       |

正则表达式语法实例：

| 正则表达式            | 对应字符串                             |
| --------------------- | -------------------------------------- |
| P(Y\|YT\|YTH\|YTHO)?N | 'PN', 'PYN', 'PYTN', 'PYTHN', 'PYTHON' |
| PYTHON+               | 'PYTHON', 'PYTHONN', 'PYTHONNN', ...   |
| PY[TH]ON              | 'PYTON', 'PYHON'                       |
| PY [ ^TH ]?ON         | 'PYON', 'PYaON', 'PYbON', ...          |
| PY{:3}N               | 'PN', 'PYN', 'PYYN', 'PYYYN'           |

经典的正则表达式：

| 正则表达式                  |                              |
| --------------------------- | ---------------------------- |
| ^[A-Za-z]+$                 | 由26个字母组成的字符串       |
| ^[A-Za-z0-9]+$              | 由26个字母和数字组成的字符串 |
| ^-?\d+$                     | 整数形式的字符串             |
| ^[0-9] * [ 1-9 ] [ 0-9 ] *$ | 正整数形式的字符串           |
| [1-9]\d{5}                  | 中国境内邮政编码             |
| [\u4e00-\u9fa5]             | 匹配中文字符（utf-8编码）    |
| \d{3}-\d{8}\|\d{4}-\d{7}    | 国内电话号码，010-68913536   |

匹配IP地址的正则表达式：

IP地址由四段组成，每段间由 ‘ . ’ 分隔，每段为0-255范围的数字。

0-255范围的数字表示：

| 0-99     | 100-199 | 200-249  | 250-255 |
| -------- | ------- | -------- | ------- |
| [1-9]?\d | 1\d{2}  | 2[0-4]\d | 25[0-5] |

IP地址的正则表达式：( ( [1-9]?\d|1\d{2}|2[0-4]\d|25[0-5] ) . ) {3} ( ( [1-9]?\d|1\d{2}|2[0-4]\d|25[0-5] ) )

### 3. 正则表达式的表示类型 

- raw string类型（原生字符串类型）：**不包含转义符**的字符串（如双引号为' “ '  而不是'  \ "  '）。当正则表达式包含转义符时，请使用raw string类型表示正则表达式
- 格式：r'text'

eg:  r'\d{3}-\d{8}|\d{4}-\d{7}'

## 二. Re库的基本使用

python的标准库，主要用于字符串匹配

调用方式：import re

### 1. Re库的主要功能函数

| 函数          | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| re.search()   | 在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象  |
| re.match()    | 从一个字符串的**开始位置**起匹配正则表达式，返回match对象    |
| re.findall()  | 搜索字符串，以**列表**类型返回**全部**能匹配的子串           |
| re.split()    | 将一个字符串按照正则表达式匹配结果进行分割，返回**列表**类型 |
| re.finditer() | 搜索字符串，返回一个匹配结果的**迭代类型**，每个迭代元素是match对象 |
| re.sub()      | 在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串 |

#### （1）re.search(pattern, string, flags=0)

在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象

- pattern：正则表达式的字符串或原生字符串表示

- string：带匹配的字符串

- flags：正则表达式使用时的控制标记

  | flag常用标记           | 说明                                                         |
  | ---------------------- | ------------------------------------------------------------ |
  | re.I（re.IGNORECASE）  | 忽略正则表达式的大小写，使得[A-Z]能够匹配小写字符            |
  | re.M  （re.MUTILINE）  | 使得正则表达式中的 ^ 操作符能够将给定字符串的每行当作匹配开始 |
  | re.S     （re.DOTALL） | 使得正则表达式中的 . 操作符能够匹配所有字符，包括换行符 (在re库中 . 默认匹配除换行符外的所有字符) |

```python
import re
match = re.search(r'[1-9]\d{5}','BIT 100081')
if match:
    print(match.group(0))
```

```
100081
```

#### （2）re.match(pattern, string, flags=0)

从一个字符串的开始位置起匹配正则表达式，返回match对象（参数说明同上）

```python
match = re.match(r'[1-9]\d{5}','BIT 100081')
if match:
    print(match.group(0))  
```

```
没有结果，因为待匹配字符串开头不是邮政编码，所以没有匹配成功，match为空
一般要对匹配的match进行非空判断，避免match为空调用方法报错
```

```python
match = re.match(r'[1-9]\d{5}','100081 BIT')
if match:
    print(match.group(0))  
```

```
100081
```

#### （3）re.findall(pattern, string, flags=0)

搜索字符串，以列表类型返回全部能匹配的子串（参数说明同上）

```python
ls = re.findall(r'[1-9]\d{5}','BIT100081 TSU100084')
ls
```

```
['100081', '100084']
```

#### （4）re.split(pattern, string, maxsplit=0flags=0)

将一个字符串按照正则表达式匹配结果进行分割，返回列表类型（参数说明同上）

maxsplit：最大分割数，剩余部分作为最后一个元素输出

```python
ls = re.split(r'[1-9]\d{5}','BIT100081 TSU100084')  #将匹配的部分删除，去掉之后的部分做为分割后的元素
ls
```

```
['BIT', ' TSU', '']
```

```python
ls = re.split(r'[1-9]\d{5}','BIT100081 TSU100084',maxsplit=1) # 只匹配一个，并分割
ls
```

```
['BIT', ' TSU100084']
```

#### （5）re.finditer(pattern, string, flags=0)

搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象（参数说明同上）

```python
for m in re.finditer(r'[1-9]\d{5}','BIT100081 TSU100084'):
    if m:
        print(m.group(0))
```

```
100081
100084
```

#### （6）re.sub(pattern, repl, string, count=0, flags=0)

在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串（参数说明同上）

- repl：替换匹配字符串的字符串

- count：匹配的最大替换次数

```python
re.sub(r'[1-9]\d{5}',':zipcode','BIT100081 TSU100084')
```

```
'BIT:zipcode TSU:zipcode'
```

### 2. Re库的等价用法

- 函数式用法——一次性操作：

```python
rst = re.search(r'[1-9]\d{5}','BIT 100081')
```

- 面向对象用法——编译后的次操作：

```python
pat = re.compile(r'[1-9]\d{5}') # 将正则表达式字符串编译为正则表达式类型pat
rst = pat.search('BIT 100081') # 经过一次编译，可以多次使用，加快程序运行
```

**re.compile(pattern, flags=0)**

将正则表达式的字符串形式编译成正则表达式对象

- pattern：正则表达式的字符串或原生字符串表示 （不是正则表达式对象，编译后才可表示正则表达式对象，即其表征的一组字符串）
- flags：正则表达式使用时的控制标记

### 3. match对象

#### （1）match对象的属性

| 属性    | 说明                                  |
| ------- | ------------------------------------- |
| .string | 待匹配的文本                          |
| .re     | 匹配时使用的pattern对象（正则表达式） |
| .pos    | 正则表达式搜索文本的开始位置          |
| .endpos | 正则表达式搜索文本的结束位置          |

```python
>>> import re
>>> m = re.search(r'[1-9]\d{5}','BIT100081 TSU100084') # 只返回第一个匹配
>>> m.string
'BIT100081 TSU100084'
>>> m.re
re.compile('[1-9]\\d{5}')
>>> m.pos
0
>>> m.endpos
19
>>> m.group(0)
'100081'
```

#### （2）match对象的方法

| 方法      | 说明                             |
| --------- | -------------------------------- |
| .group(0) | 获得匹配后的字符串               |
| .start()  | 匹配字符串在原始字符串的开始位置 |
| .end()    | 匹配字符串在原始字符串的结束位置 |
| .span()   | 返回（.start( ), .end( )）       |

### 4. Re库的贪婪匹配和最小匹配

- Re库默认采用贪婪匹配，即输出匹配最长的子串

```python
>>> match = re.search(r'PY.*N', 'PYANBNCNDN')
# 有4种可能结果 'PYAN', 'PYANBN', 'PYANBNCN', 'PYANBNCNDN'
>>> match.group(0)
'PYANBNCNDN'
```

- 最小匹配

| 操作符 | 说明                                  |
| ------ | ------------------------------------- |
| *？    | 前一个字符0次或无限次扩展，最小匹配   |
| +？    | 前一个字符1次或无限次扩展，最小匹配   |
| ？？   | 前一个字符0次或1次扩展，最小匹配      |
| {m,n}? | 扩展前一个字符m至n次（含n），最小匹配 |

```python
>>> match = re.search(r'PY.*?N', 'PYANBNCNDN')
>>> match.group(0)
'PYAN'
```

